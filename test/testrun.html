<!DOCTYPE html>
<html>
<head>
  <style type="text/css">@import "jquery/jquery.svg.css";</style>
  <script type="text/javascript" src="jquery/jquery-1.8.1.js"></script>
  <script type="text/javascript" src="heap.js"></script>
  <script type="text/javascript" src="alarmer.js"></script>
  <script type="text/javascript" src="keyboardlayout.js"></script>
  <script type="text/javascript" src="raphael-min.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      BouncingBall = function(paper, x, y, r, vx, vy, options) {
        this.paper = paper;
        this.svg_circle = paper.circle(x, y, r);

        this.bound_w = this.paper.width;
        this.bound_h = this.paper.height;

        this.radius = r;
        this.color = options["color"] || "black";

        this.cx = x;
        this.cy = y;

        this.vx = vx;
        this.vy = vy;

        this.update_svg();
      };

      BouncingBall.prototype.update_svg = function() {
        var x = Math.floor(this.cx),
            y = Math.floor(this.cy),
            r = Math.floor(this.radius);
        this.svg_circle.attr("cx", x).
                        attr("cy", y).
                        attr("r", r).
                        attr("fill", this.color);
      };

      BouncingBall.prototype.tick = function(dt) {
        var n_list = this.new_vals(this.cx, this.cy, this.vx, this.vy, dt);
        this.cx = n_list[0];
        this.cy = n_list[1];
        this.vx = n_list[2];
        this.vy = n_list[3];
        this.update_svg();
      };

      // Returns new x, y, vx, vy.
      BouncingBall.prototype.new_vals = function(x, y, vx, vy, dt) {
        var n_x = x + vx * dt,
            n_y = y + vy * dt;
        // Detect boundary collisions.
        // These contain the amount we are past the boundary.
        var e_t_x = 0,
            e_t_y = 0;
        // Find out how much time we would travel out of bounds in either
        // dimension.
        if (n_x > this.bound_w - this.radius) {
          var e_x = n_x - (this.bound_w - this.radius);
          e_t_x = dt * Math.abs(e_x / (n_x - x));
        } else if (n_x < this.radius) {
          var e_x = n_x - this.radius;
          e_t_x = dt * Math.abs(e_x / (n_x - x));
        }
        if (n_y > this.bound_h - this.radius) {
          var e_y = n_y - (this.bound_h - this.radius);
          e_t_y = dt * Math.abs(e_y / (n_y - y));
        } else if (n_y < this.radius) {
          var e_y = n_y - this.radius;
          e_t_y = dt * Math.abs(e_y / (n_y - y));
        }
        if (e_t_y > 0 || e_t_x > 0) {
          // A collision occurred in at least one dimension.
          // We use the one that we hit first (the most time spent out of
          // bounds). Once we know that, we make a bounce happen by setting
          // the new dt to the time spent out of bounds, set the position to
          // the location of the collision, and reverse the appropriate
          // velocity. We then try again from this new point.
          if (e_t_x > e_t_y) {
            var n_dt = dt - e_t_x;
            return this.new_vals(
                x + vx * n_dt,
                y + vy * n_dt,
                -vx,
                vy,
                e_t_x);
          } else {
            var n_dt = dt - e_t_y;
            return this.new_vals(
                x + vx * n_dt,
                y + vy * n_dt,
                vx,
                -vy,
                e_t_y);
          }
        }
        return [n_x, n_y, vx, vy];
      };

      alarm = new Alarmer();

      alarm.add("motion", function() {
          paper = Raphael("div_viewport");
          var colors = ["red", "green", "blue", "orange", "pink", "purple"];
          var balls = [];
          var num_balls = 250;
          var radius = 20;
          for (var i=0; i < num_balls; ++i) {
            var vx = Math.random() * paper.width/4 + paper.width/4;
            var vy = Math.random() * paper.height/-17 + paper.height/4;
            var ball = new BouncingBall(
              paper,
              Math.floor(Math.random() * (paper.width - 2 * radius) + radius),
              Math.floor(Math.random() * (paper.height - 2 * radius) + radius),
              radius,
              vx * ((Math.random() > 0.5) ? 1 : -1),
              vy * ((Math.random() > 0.5) ? 1 : -1),
              {color: colors[Math.floor(Math.random() * colors.length)]});
            balls.push(ball);
          }
          return function(name, elapsed_ms, dt_ms) {
            for (var i=0, len=balls.length; i<len; ++i) {
              balls[i].tick(dt_ms / 1000.0);
            }
            return true;
          };}(), 50, 50);

      $("#btn_start").
        val("Start").
        click(function(evt) {
          var target = evt.delegateTarget;
          if (alarm.running()) {
            alarm.pause();
            target.value = "Start";
          } else {
            alarm.start();
            target.value = "Pause";
          }
        });
    });

  </script>
  <style type="text/css">
    #div_viewport {
      display: inline-block;
      border: 1px black solid;
      margin: 1px;
      height: 400px;
      width: 500px;
    }
  </style>
</head>
<body>
  <div id="div_viewport">
  </div>
  <form>
    <input id="btn_start" type="button" value="Start">
  </form>
</body>
</html>
